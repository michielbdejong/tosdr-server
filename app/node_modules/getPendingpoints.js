'use strict';

module.exports = function(req, res, next){
    var q = module.require('q'),
        fs = module.require('fs'),
        path = module.require('path'),
        config = module.require('config'),
        crypto = module.require('crypto');

    if(!config.comments || !config.comments.target){
        console.log('Location of pending data points should be defined');
        return next();
    }

    var defer = q.defer(),
        pendingpointsDir = path.resolve(path.dirname(module.parent.filename), '../', config.comments.target);

    fs.exists(pendingpointsDir, defer.resolve);
    var p = defer.promise;
    p.then(
		function(exists){
			if(exists){
				return;
			}
			var mkdirDefer = q.defer();
			fs.mkdir(pendingpointsDir, mkdirDefer.resolve);
			return mkdirDefer.promise;
		}
	)
    .then(function(){ return q.nfcall(fs.readdir, pendingpointsDir); })
    .then(function(files){
        // Read all files in services/*.json,
        // saving the value of the 'id' field to the services array
        var md5sum;
        return files.reduce(function(soFar, file){
            if(file.substr(-5) !== '.json'){
                return soFar;
            }
            return soFar.then(function(pendingpoints){
                return q.nfcall(fs.readFile, path.resolve(pendingpointsDir, file))
                .then(function(contents){
                    pendingpoints = pendingpoints || [];
                    contents = JSON.parse(contents);
                    // Obfuscate email addresses
                    md5sum = crypto.createHash('md5');
                    md5sum.update(contents.meta.author);
                    contents.meta.author = md5sum.digest('hex');
                    if(contents.meta.contributors){
                        contents.meta.contributors.forEach(function(v, i){
                            md5sum = crypto.createHash('md5');
                            md5sum.update(v);
                            contents.meta.contributors[i] = md5sum.digest('hex');
                        });
                    }
                    contents.comments.forEach(function(v, i){
                        md5sum = crypto.createHash('md5');
                        md5sum.update(v.author);
                        contents.comments[i].author = md5sum.digest('hex');
                    });
                    pendingpoints.push(contents);
                    return pendingpoints;
                });
            });
        }, q([]));
    })
    .then(function(pendingpoints){
        res.send(200, pendingpoints);
    })
    .fail(function(error){
        console.error(error);
        res.send(500);
    });
};